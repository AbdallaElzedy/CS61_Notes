<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Harvard CS61 Notes - Memory Pattern</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        
        h1 {
            color: #A51C30;
            border-bottom: 3px solid #A51C30;
            padding-bottom: 10px;
            margin-bottom: 30px;
        }
        
        .container {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .quick-reference {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .ref-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #A51C30;
        }
        
        .ref-card h3 {
            margin-top: 0;
            color: #333;
        }
        
        .analyzer {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        
        textarea {
            width: 100%;
            min-height: 150px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            background: #1e2936;
            color: #0f0;
        }
        
        button {
            background: #A51C30;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 10px;
        }
        
        button:hover {
            background: #871429;
        }
        
        .results {
            margin-top: 20px;
            padding: 15px;
            background: #34495e;
            border-radius: 5px;
            min-height: 100px;
        }
        
        .pattern-match {
            background: #27ae60;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }
        
        .pattern-info {
            background: #3498db;
            color: white;
            padding: 10px;
            border-radius: 5px;
            margin: 5px 0;
        }
        
        code {
            background: #ecf0f1;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #2c3e50;
        }
        
        .hint {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 10px;
            margin: 10px 0;
            color: #856404;
        }
    </style>
</head>
<body>
    <h1>Harvard CS61 Notes - Memory Pattern Analyzer</h1>
    
    <div class="container">
        <h2>Quick Pattern Recognition Guide</h2>
        <div class="quick-reference">
            <div class="ref-card">
                <h3>Address Patterns</h3>
                <p><strong>Sequential addresses:</strong> Likely <code>std::vector</code></p>
                <p><strong>Non-sequential addresses:</strong> Likely <code>std::list</code></p>
                <p><strong>Address gaps:</strong> Gap size = element size</p>
            </div>
            
            <div class="ref-card">
                <h3>Common Data Sizes</h3>
                <p><strong>1 byte:</strong> <code>char</code>, <code>bool</code></p>
                <p><strong>4 bytes:</strong> <code>int</code>, <code>float</code></p>
                <p><strong>8 bytes:</strong> <code>long</code>, <code>double</code>, pointers</p>
                <p><strong>32 bytes:</strong> <code>std::string</code> (typical)</p>
            </div>
            
            <div class="ref-card">
                <h3>std::string Layout</h3>
                <p><strong>First 8 bytes:</strong> Pointer to data</p>
                <p><strong>Next 8 bytes:</strong> String length</p>
                <p><strong>Last 16 bytes:</strong> SSO buffer</p>
                <p><em>SSO = Small String Optimization</em></p>
                <p><strong>Total size:</strong> 32 bytes (0x20)</p>
            </div>
            
            <div class="ref-card">
                <h3>ASCII Quick Ref</h3>
                <p><code>0x31</code> = '1', <code>0x32</code> = '2', etc.</p>
                <p><code>0x41</code> = 'A', <code>0x61</code> = 'a'</p>
                <p><code>0x20</code> = space, <code>0x00</code> = null</p>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h2>Detailed std::string Recognition Guide</h2>
        <div class="ref-card" style="background: #e8f4fd; border-left-color: #2196F3;">
            <h3>std::string Memory Layout (32 bytes total)</h3>
            <pre style="background: #263238; color: #aed581; padding: 15px; border-radius: 5px; overflow-x: auto;">
Offset  Size   Purpose            Example
------  ----   -------            -------
0x00    8      Data pointer       50 00 00 00 0c 72 00 00  ‚Üí points to 0x720c00000050
0x08    8      String length      0a 00 00 00 00 00 00 00  ‚Üí length = 10
0x10    16     SSO buffer         43 53 36 31 2d 52 6f 63  ‚Üí "CS61-Roc"
                                  6b 73 00 00 00 00 00 00  ‚Üí "ks" + nulls</pre>
            
            <h4>Key Recognition Patterns:</h4>
            <ul>
                <li><strong>Short strings (‚â§ 15 chars):</strong> Stored directly in SSO buffer, pointer points to offset 0x10 of the string object</li>
                <li><strong>Long strings (> 15 chars):</strong> Stored on heap, pointer points to heap address</li>
                <li><strong>Length field:</strong> Always at offset 0x08, stored as little-endian 64-bit integer</li>
                <li><strong>Null padding:</strong> SSO buffer is padded with 0x00 after string content</li>
            </ul>
            
            <h4>How to Decode:</h4>
            <ol>
                <li>Check bytes 8-15 for the length (little-endian)</li>
                <li>If length ‚â§ 15, read ASCII from bytes 16-31 (SSO buffer)</li>
                <li>If length > 15, the first 8 bytes point to heap location</li>
                <li>Convert hex to ASCII: 0x43='C', 0x53='S', 0x36='6', 0x31='1', 0x2D='-', 0x52='R', 0x6F='o', 0x63='c'</li>
            </ol>
        </div>
    </div>
    
    <div class="container analyzer">
        <h2>üîç Memory Pattern Analyzer</h2>
        <p>Paste memory dump output below to analyze container and data types:</p>
        <textarea id="memoryInput" placeholder="7208'0000'0020  01 00 00 00
7208'0000'0024  02 00 00 00
..."></textarea>
        <button onclick="analyzeMemory()">Analyze Pattern</button>
        <div id="results" class="results"></div>
    </div>
    
    <div class="container">
        <h2>Pattern Recognition Tips</h2>
        <div class="hint">
            <strong>Tip 1:</strong> Calculate address differences first! Sequential with consistent gaps = vector
        </div>
        <div class="hint">
            <strong>Tip 2:</strong> Look at value patterns: 01, 02, 03... suggests integers; 31, 32, 33... suggests ASCII chars
        </div>
        <div class="hint">
            <strong>Tip 3:</strong> For strings, check for null terminators (00) and readable ASCII in the buffer area
        </div>
    </div>

    <script>
        function analyzeMemory() {
            const input = document.getElementById('memoryInput').value.trim();
            const results = document.getElementById('results');
            
            if (!input) {
                results.innerHTML = '<div class="pattern-info">Please paste memory dump data to analyze</div>';
                return;
            }
            
            const lines = input.split('\n').filter(line => line.trim());
            const addresses = [];
            const values = [];
            
            // Parse memory dump
            lines.forEach(line => {
                const parts = line.trim().split(/\s+/);
                if (parts.length >= 2) {
                    const addr = parts[0].replace(/'/g, '');
                    addresses.push(parseInt(addr, 16));
                    values.push(parts.slice(1).join(' '));
                }
            });
            
            let analysis = '';
            
            // Check address pattern
            let sequential = true;
            let addressGap = 0;
            if (addresses.length > 1) {
                addressGap = addresses[1] - addresses[0];
                for (let i = 2; i < addresses.length; i++) {
                    if (addresses[i] - addresses[i-1] !== addressGap) {
                        sequential = false;
                        break;
                    }
                }
            }
            
            if (sequential && addressGap > 0) {
                analysis += `<div class="pattern-match">‚úì Sequential addresses with gap of ${addressGap} bytes ‚Üí Likely <strong>std::vector</strong></div>`;
                
                // Determine data type based on gap size
                if (addressGap === 1) {
                    analysis += '<div class="pattern-info">1-byte elements ‚Üí Likely <strong>char</strong> or <strong>bool</strong></div>';
                } else if (addressGap === 4) {
                    analysis += '<div class="pattern-info">4-byte elements ‚Üí Likely <strong>int</strong> or <strong>float</strong></div>';
                } else if (addressGap === 8) {
                    analysis += '<div class="pattern-info">8-byte elements ‚Üí Likely <strong>long</strong>, <strong>double</strong>, or pointer</div>';
                } else if (addressGap === 32) {
                    analysis += '<div class="pattern-info">32-byte elements ‚Üí Likely <strong>std::string</strong></div>';
                }
            } else {
                analysis += '<div class="pattern-match">‚úì Non-sequential addresses ‚Üí Likely <strong>std::list</strong></div>';
            }
            
            // Analyze values
            const firstValue = values[0];
            if (firstValue) {
                const bytes = firstValue.split(/\s+/);
                
                // Check for ASCII characters
                if (bytes.length === 1) {
                    const val = parseInt(bytes[0], 16);
                    if (val >= 0x30 && val <= 0x39) {
                        analysis += '<div class="pattern-info">Values are ASCII digits (\'0\'-\'9\')</div>';
                    } else if (val >= 0x41 && val <= 0x7A) {
                        analysis += '<div class="pattern-info">Values are ASCII letters</div>';
                    }
                }
                
                // Check for string pattern (32 bytes with pointer, length, buffer)
                if (bytes.length >= 16) {
                    analysis += '<div class="pattern-info">Large data blocks detected - analyzing for std::string pattern...</div>';
                    
                    // Detailed string analysis
                    if (bytes.length >= 32 || (lines.length > 1 && bytes.length >= 16)) {
                        // Extract length (bytes 8-15)
                        let stringLength = 0;
                        if (bytes.length >= 16) {
                            // Parse little-endian 64-bit length
                            for (let i = 8; i < Math.min(16, bytes.length); i++) {
                                stringLength += parseInt(bytes[i], 16) * Math.pow(256, i - 8);
                            }
                            
                            if (stringLength > 0 && stringLength < 1000) { // Reasonable string length
                                analysis += `<div class="pattern-match">‚úì String length detected: ${stringLength} characters</div>`;
                            }
                        }
                        
                        // Look for ASCII in buffer area
                        const bufferStart = 16;
                        let asciiChars = [];
                        let hasAscii = false;
                        
                        for (let i = bufferStart; i < Math.min(bytes.length, 32); i++) {
                            const val = parseInt(bytes[i], 16);
                            if (val >= 0x20 && val <= 0x7E) {
                                hasAscii = true;
                                asciiChars.push(String.fromCharCode(val));
                            } else if (val === 0x00) {
                                break; // Stop at null terminator
                            }
                        }
                        
                        if (hasAscii) {
                            analysis += '<div class="pattern-match">‚úì ASCII text found in SSO buffer: <strong>"' + asciiChars.join('') + '"</strong></div>';
                            analysis += '<div class="pattern-match">‚úì Confirms <strong>std::string</strong> with Small String Optimization</div>';
                        }
                        
                        // Show memory layout breakdown
                        if (bytes.length >= 24) {
                            analysis += '<div class="pattern-info" style="font-family: monospace; background: #1e2936; padding: 10px; margin-top: 10px;">';
                            analysis += '<strong>Memory Layout Breakdown:</strong><br>';
                            analysis += `Pointer (0-7): ${bytes.slice(0, 8).join(' ')}<br>`;
                            analysis += `Length (8-15): ${bytes.slice(8, 16).join(' ')} = ${stringLength} chars<br>`;
                            if (bytes.length >= 32) {
                                analysis += `SSO Buffer (16-31): ${bytes.slice(16, 32).join(' ')}<br>`;
                            }
                            analysis += '</div>';
                        }
                    }
                }
            }
            
            results.innerHTML = analysis || '<div class="pattern-info">Unable to determine pattern - check input format</div>';
        }
        
        // Auto-analyze on paste
        document.getElementById('memoryInput').addEventListener('paste', function() {
            setTimeout(analyzeMemory, 100);
        });
    </script>
</body>
</html>
